# HTTP 缓存

## 强缓存

在 HTTP1 时通过 expires 标识，在 HTTP1.1 通过 Cache-Control 标识

* Expires

  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  标识资源在某一时间过期（但是客户端和服务端的时间可能不一致）

* Cache-Control

  Cache-Control:max-age=3600
  通过过期时长来控制缓存

  属性

  + private： 只有浏览器能缓存，中间代理服务器不能缓存
  + no-cache: 跳过当前强缓存，发送 HTTP 请求（直接进入协商缓存中）
  + no-store： 不进行任何形式的缓存
  + s-maxage：指定代理服务器的缓存时间
  + must-revalidate： 缓存过期，必须回到源服务器验证

### 通过 Cache-Control 验证强缓存是否可用

* 如果可用，直接使用
* 否则进入协商缓存（发送请求，服务器通过请求头中的 If-Modified-Since 或 If-None-Match 这些条件请求字段检查资源是否更新）
  + 如果资源更新，返回资源和200状态码
  + 否则返回304，从缓存中获取

## 协商缓存

当强缓存失效后，浏览器会在请求头中携带响应的缓存 tag ，服务器根据 tag 来决定是否使用缓存

### Last-Modified

最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在响应头中添加这个字段

浏览器接受后，如果再次请求，会携带 If-Modified—Since（服务器传来的最后修改时间） 字段

服务器拿这个时间和资源的最后修改时间对比

* 如果请求的时间小，则证明资源被更新，返回新的资源
* 返回 304 告诉浏览器直接用缓存

### ETag

是服务器根据文件内容给文件生成的唯一标识，只要内容有所改动，这个值就会变，服务器通过响应头将这个值给浏览器

浏览器在接受到值后，将值作为 If-None-Match 字段的内容，放到请求头中

服务器对比两个 ETag

* 如果不一样，则更新资源
* 一样，返回304

### ETag 和 Last-Modified 对比

* 精准度： ETag 更准确感知资源的变化
  + 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  + Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了
* 性能： Last-Modified 只是一个节点 ETag 是根据文件内容生成的 哈希值

## 代理缓存

假如客户端缓存失效，都要从服务器获取，那么给源服务器的压力很大

### 原理

让代理服务器接管一部分的服务端 HTTP 缓存，客户端缓存过期后，就近到代理缓存中获取，代理缓存过期才会请求源服务器

#### 源服务器缓存控制

在源服务器的响应头中，假如 Cache-Control 这个字段进行缓存控制字段，值为 private（禁止），public（允许）

* must-revalidate 表示客户端缓存过期，需要的源服务器获取
* proxy-revalidate 表示代理服务器缓存过期，需要到源服务器获取
* s-maxage  用于限定缓存在代理服务器中可以存放多久

#### 客户端的缓存控制

* max-stale 表示在代理过期的多少秒内，仍可以从代理中获取
* min-fresh 表示必须在缓存到期前多少秒内获取，否则拿不到
* only-if-cached 仅接受代理服务器缓存，如果代理服务器无效，则直接返回 504

# 缓存位置

优先级由高到底排列

* Service Worker
* Memory Cache
* Disk Cache
* Push Cache

## Service Worker

让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM。

虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 Service Worker Cache。

## Memory Cache

内存缓存，存活时间短，当渲染进程结束，内存缓存就消失

## Disk Cache

磁盘缓存

* 较大的 JS 和 CSS 文件会先存放到内存中
* 内存使用率较高时，文件有限进入磁盘

## Push Cache

推送缓存，是 HTTP2 的内容

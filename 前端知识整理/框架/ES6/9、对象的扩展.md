# 第九章：对象的扩展

1. 属性的简洁声明

	let foo = 'bar'
	let baz = {foo}   ==>   等价于let baz = {foo : 'bar'}

2. 方法的简写声明

method() {}   ==>  method:function () {}

3. 定义对象的两种方法
	1. obj.foo = true     直接使用标识符作为属性名
	2. obj[abc'] = 123     直接用表达式作为属性名

		如果使用let test = {a:b,c:d}时，在ES5中只能使用方法一来定义。在ES6中可以通过{['a']:'b'}也就是方法二来定义。

4. 新添方法

   1. Object.is()用来比较两个值是否严格相等和严格相等运算符（===）一样
   	因为在ES5 中只有==和===来比较，但是前者会自动转换类型，后者的NaN不等于自身，以及+0和-0也不相等。

   1. Object.assign用于将源对象的所有可枚举属性复制到目标对象

		Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
		let a = {a:1}
		let b = {b:2}
		let c = {c:3}
		Object.assign(a,b,c)  ===>  a = {a:1,b:2,c:3}
		注意：

      1. 如果目标对象与源对象具有同名属性，或者多个源对象具有同名属性，则后面的属性会覆盖前面的属性。
      2. 如果源对象的值是一个对象时，那么目标对象复制得到的时这个对象的引用

      Object.assign方法的用途
         1. 为对象添加属性
         class point {
         constructor(x,y) {Object.assign(this,{x,y})}}
         上面方法通过 assign 方法将 x 属性和 y 属性添加到 Point 类的对象实例中

         1. 为对象添加方法
         Object.assign(prototype,{someMethod () {}})

         1. 合并多个对象
         const merge = (target , ...sources)  =>  Object.assign(target , ...sources)

1. 属性的遍历

共有 5 中方法可以遍历对象的属性

1. for  。。。in

	for(var key in obj){} 获得obj中的key，通过obj[key] 获得value

	以下四种均返回一个数组

	2. Object.key(Obj) 包含对象自身的所有可枚举的属性
	3. Object.getOwnPropertyNames(Obj) 包含对象自身的所有属性（包括不可枚举属性，不包括Symbol）
	4. Object.getOwnPropertySymbols(obj)（包含自身所有Symbol属性）
	5. Reflect.ownKeys(obj) （包含对象自身的所有属性，不管对象名是Symbol还是字符串，也不管是否可以枚举）

	6. _proto_属性：用来读取或设置当前对象的 prototype 对象。

	由于_proto_是一个内部属性，所以最好不要使用这个属性，而使用

	1. Object.setPrototypeOf()(写操作)
	2. Object.getPrototypeOf()(读操作)
	3. Object.create()(生成操作)


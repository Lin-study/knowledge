# v8引擎

> 只有1.4G的内存可以支配，在node中可以使用1.4以上（使用了c++的内存）

v8的内存回收是在内存快要满的时候才会进行内存回收，
两种情况下不会进行内存回收

* 全局变量
* 局部变量没有失去引用的时候

为什么不经常的进行内存回收，因为当内存回收的时候会中断js的执行（回收100M的内存需要10ms）

## 容易引发内存使用不当的情景

* 滥用全局变量
* 缓存不做限制
* 操作大文件

## 渲染工作流程

* 渲染进程将 HTML 内容转换为能够读懂DOM 树结构。
* 渲染引擎将 CSS 样式表转化为浏览器可以理解的styleSheets，计算出 DOM 节点的样式。
* 创建布局树，并计算元素的布局信息。
* 对布局树进行分层，并生成分层树。
* 为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转换成位图。
* 合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上。

# 内存查看

* 浏览器

  通过window.performance即可获取到性能数据

* node

  通过Node-process.memoryUsage()获取到内存

``` JS
function format(b) {
  return (b / 1024 / 1024).toFixed(2) + 'MB'
}

function getme() {
  let mem = process.memoryUsage()
  console.log('heapTotal: ' + format(mem.heapTotal) + 'heapUsed:' + format(mem.heapUsed))
}
```

# 垃圾回收

![](./img/v8垃圾回收.jpg)

# 进程共用

网络进程、GPU进程是共享的，不会重新启动，如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们也会共用一个渲染进程，否则新开一个渲染进程。
# 代码层面

1. v-if 和 v-show

v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

2. computed 和 watch

computed：依赖其它属性值，并且值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

运用场景：

* 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

* 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

3. v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

* v-for 遍历必须为 item 添加 key

在进行遍历渲染时，需要唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。

* v-for 遍历避免同时使用 v-if

v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，必要情况下应该替换成 computed 属性。

4. 长列表性能优化

有些时候我们的组件就是纯粹的数据展示，不会有任何改变，就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。

可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

5. 事件销毁

在组件销毁时，不会销毁通过 addEventListener 等方式添加的事件，我们需要在组件的 destroy 生命周期中手动移除，避免内存泄露

``` JS
export default {
  methods: {
    click() {}
  },
  created() {
    addEventListener('click', this.click, false)
  },
  destroy() {
    removeEventListener('click', this.click, false)
  }
}
```

6. 图片资源懒加载

通过 vue-lazyload 插件实现

``` JS
// 在入口的  main.js 引入并使用
import VueLazyload from 'vue-lazyload'
Vue.use(VueLazyload)
```

``` HTML
<!-- 对图片的懒加载 -->
<img v-lazy='/static/img/1.png'>
```

7. 路由懒加载

当很多的路由引入时，webpcak 打包的文件很大，当进入首页时，加载的资源过多，出现白屏。

把不同路由对应的组件分割，然后当路由被访问的时才加载组件。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。

``` JS
const Foo = () => import('./Foo.vue')
const router = new VueRouter({
  routes: [{
    path: '/foo',
    component: Foo
  }]
})
```

8. 优化无限列表性能

如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller  来优化这种无限列表的场景的。

9. 服务端渲染 SSR or 预渲染

服务端渲染是渲染整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。

（1）服务端渲染的优点：

更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

首屏加载更快：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

（2）服务端渲染的缺点：

更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；

更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。

如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO。

如果你的 Vue 项目只需改善少数营销页面的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。

